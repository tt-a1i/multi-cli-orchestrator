The JSON findings have been returned above. 11 findings total: 3 high (path traversal, file handle leak, silent exception swallowing), 5 medium (orphaned processes, non-atomic writes, shell injection, no logging, missing concurrency tests), 3 low (redundant JSON parsing, empty path config, CLI error path test gap).
mpute_delay(retry_index))\n# Loop continues back to while True with no time.sleep()"},"recommendation":"Add time.sleep(delay) after computing the delay: delay = self.retry_policy.compute_delay(retry_index); delays.append(delay); time.sleep(delay)","confidence":1.0,"fingerprint":"a3f7c1e2-orchestrator-retry-no-sleep"},{"finding_id":"F002","severity":"high","category":"security","title":"command_override from metadata dict passed directly to subprocess.Popen without validation","evidence":{"file":"runtime/adapters/shim.py","line":79,"symbol":"ShimAdapterBase.run","snippet":"command_override = input_task.metadata.get(\"command_override\")\ncmd = command_override if isinstance(command_override, list) else self._build_command(input_task)"},"recommendation":"Validate command_override entries are strings, non-empty, and match an allowlist of known binaries. Reject or sanitize unexpected values before passing to Popen.","confidence":0.85,"fingerprint":"b8d2a4f1-shim-command-override-injection"},{"finding_id":"F003","severity":"high","category":"bug","title":"Unhandled JSONDecodeError when loading corrupted state file crashes the application","evidence":{"file":"runtime/orchestrator.py","line":66,"symbol":"OrchestratorRuntime._load_state","snippet":"data = json.loads(self.state_file.read_text(encoding=\"utf-8\"))"},"recommendation":"Wrap json.loads in try/except json.JSONDecodeError. On corruption, log a warning and start with empty state rather than crashing.","confidence":1.0,"fingerprint":"c4e9b3d7-orchestrator-state-json-crash"},{"finding_id":"F004","severity":"high","category":"bug","title":"Unhandled JSONDecodeError when loading cached run.json file crashes on corrupted data","evidence":{"file":"runtime/review_engine.py","line":115,"symbol":"run_review","snippet":"existing = json.loads(run_file.read_text(encoding=\"utf-8\"))"},"recommendation":"Wrap json.loads in try/except json.JSONDecodeError. On failure, treat as if no cached result exists and re-run the review.","confidence":1.0,"fingerprint":"d5f8c2a6-review-engine-run-json-crash"},{"finding_id":"F005","severity":"medium","category":"security","title":"Default artifact_root falls back to shared /tmp directory without path validation","evidence":{"file":"runtime/adapters/shim.py","line":84,"symbol":"ShimAdapterBase.run","snippet":"artifact_root = str(input_task.metadata.get(\"artifact_root\", \"/tmp/multi-cli-orchestrator\"))"},"recommendation":"Remove /tmp fallback; require explicit artifact_root. Validate the path with Path.resolve() to prevent directory traversal via ../","confidence":0.9,"fingerprint":"e6a7d1b5-shim-tmp-default-path"},{"finding_id":"F006","severity":"medium","category":"security","title":"Shell command injection pattern in _resolve_binary via f-string interpolation into bash -lc","evidence":{"file":"runtime/adapters/shim.py","line":218,"symbol":"ShimAdapterBase._resolve_binary","snippet":"result = subprocess.run(\n    [\"bash\", \"-lc\", f\"command -v {self.binary_name}\"],\n    capture_output=True, text=True, check=False,\n)"},"recommendation":"Use shlex.quote(self.binary_name) to escape the value, or use shutil.which() instead of shelling out to bash for binary resolution.","confidence":0.8,"fingerprint":"f7b8e2c4-shim-resolve-binary-injection"},{"finding_id":"F007","severity":"medium","category":"bug","title":"File handle close exceptions silently swallowed may cause incomplete data reads","evidence":{"file":"runtime/adapters/shim.py","line":154,"symbol":"ShimAdapterBase.poll","snippet":"try:\n    handle.stdout_file.close()\n    handle.stderr_file.close()\nexcept Exception:\n    pass"},"recommendation":"Log the exception at warning level. If close fails, stdout/stderr data may be unflushed. Consider using context managers for file handles or calling flush() explicitly before read.","confidence":0.85,"fingerprint":"a1c3d5e7-shim-poll-silent-close-exception"},{"finding_id":"F008","severity":"medium","category":"security","title":"State file written without restricted permissions - sensitive dispatch data may be world-readable","evidence":{"file":"runtime/orchestrator.py","line":118,"symbol":"OrchestratorRuntime._persist_state","snippet":"tmp = self.state_file.with_suffix(self.state_file.suffix + \".tmp\")\ntmp.write_text(json.dumps(payload, ensure_ascii=True, indent=2), encoding=\"utf-8\")\ntmp.replace(self.state_file)"},"recommendation":"Set file permissions to 0o600 after writing: os.chmod(str(tmp), 0o600) before the replace call. Also set parent directory permissions to 0o700 on creation.","confidence":0.75,"fingerprint":"b2d4f6a8-orchestrator-state-file-perms"},{"finding_id":"F009","severity":"medium","category":"security","title":"No validation that repo_root exists or target_paths are within repo_root scope","evidence":{"file":"runtime/review_engine.py","line":165,"symbol":"run_review.runner","snippet":"input_task = TaskInput(\n    task_id=resolved_task_id,\n    prompt=full_prompt,\n    repo_root=request.repo_root,\n    target_paths=target_paths,\n    timeout_seconds=request.policy.timeout_seconds,\n    metadata={\"artifact_root\": request.artifact_base},\n)"},"recommendation":"Validate repo_root exists with Path(repo_root).is_dir(). Verify each target_path resolves within repo_root using Path.resolve() containment check.","confidence":0.8,"fingerprint":"c3e5a7b9-review-engine-no-path-validation"},{"finding_id":"F010","severity":"low","category":"maintainability","title":"All 5 adapters duplicate identical normalize() method that could be in base class","evidence":{"file":"runtime/adapters/claude.py","line":49,"symbol":"ClaudeAdapter.normalize","snippet":"def normalize(self, raw: Any, ctx: NormalizeContext) -> List[NormalizedFinding]:\n    text = raw if isinstance(raw, str) else \"\"\n    return normalize_findings_from_text(text, ctx, \"claude\")"},"recommendation":"Move the common normalize() implementation into ShimAdapterBase, using self.id as the provider parameter. Remove the override from all 5 adapter subclasses.","confidence":0.95,"fingerprint":"d4f6b8c0-adapters-duplicate-normalize"},{"finding_id":"F011","severity":"low","category":"maintainability","title":"TaskStateMachine error message omits valid transitions making debugging difficult","evidence":{"file":"runtime/orchestrator.py","line":47,"symbol":"TaskStateMachine.transition","snippet":"raise ValueError(f\"illegal transition {self.state} -> {next_state}\")"},"recommendation":"Include valid transitions in the error: valid = VALID_TRANSITIONS[self.state]; raise ValueError(f'Cannot transition {self.state} -> {next_state}. Valid: {valid}')","confidence":0.9,"fingerprint":"e5a7c9d1-orchestrator-terse-transition-error"},{"finding_id":"F012","severity":"medium","category":"test-gap","title":"No tests verify retry delay is actually applied - retry busy-loop bug went undetected","evidence":{"file":"runtime/orchestrator.py","line":159,"symbol":"run_with_retry","snippet":"while True:\n    attempts += 1\n    result = runner(attempts)"},"recommendation":"Add test that patches time.sleep and verifies it is called with expected backoff delays between retry attempts.","confidence":0.95,"fingerprint":"f6b8d0e2-orchestrator-retry-test-gap"},{"finding_id":"F013","severity":"medium","category":"test-gap","title":"No tests for corrupted state file or run.json recovery - crash paths untested","evidence":{"file":"runtime/orchestrator.py","line":66,"symbol":"_load_state","snippet":"data = json.loads(self.state_file.read_text(encoding=\"utf-8\"))"},"recommendation":"Add tests that write invalid JSON to state_file and run.json, then verify graceful recovery instead of JSONDecodeError crash.","confidence":0.95,"fingerprint":"a7c9e1f3-state-corruption-test-gap"}]}
```
